# 古诗文默写数据库新数据结构使用说明

## 概述

新的数据结构按照您的要求重新整理，将古诗文默写分为两大类：
1. **前后文默写** - 传统的根据前半句填写后半句或根据后半句填写前半句
2. **理解性默写** - 根据问题含义默写相关句子

每篇古诗文都有唯一的ID，理解性默写的每个句子也有单独的ID，方便调用和随机默写。

## 数据结构说明

### 1. 前后文默写类 (contextual)

```javascript
'01_quanxue': {
    id: '01_quanxue',           // 唯一标识符
    title: '劝学',              // 标题
    author: '荀子',             // 作者
    content: '完整内容...',     // 完整文本
    sentences: [                // 句子数组
        { 
            id: '01_quanxue_1', // 句子唯一ID
            front: '前半句',     // 前半句内容
            back: '后半句'       // 后半句内容（空字符串表示没有后半句）
        }
    ]
}
```

### 2. 理解性默写类 (comprehensive)

```javascript
'01_quanxue_comp': {
    id: '01_quanxue_comp',      // 唯一标识符
    title: '劝学 - 理解性默写', // 标题
    author: '荀子',             // 作者
    sourcePoem: '01_quanxue',   // 对应的原文ID
    questions: [                 // 问题数组
        {
            id: '01_quanxue_comp_1', // 问题唯一ID
            question: '问题内容',      // 问题描述
            answer: '标准答案',        // 正确答案
            hint: '提示信息'          // 提示内容
        }
    ]
}
```

## 练习模式配置

### 1. 前后文默写模式
- **fillBack**: 默写后一句（根据前半句填写后半句）
- **fillFront**: 默写前一句（根据后半句填写前半句）

### 2. 理解性默写模式
- **meaning**: 理解性默写（根据问题含义默写相关句子）

## 使用方法

### 1. 获取单篇古诗文

```javascript
// 获取前后文默写
const poem = utils.getPoemById('01_quanxue');

// 获取理解性默写
const comp = utils.getComprehensiveById('01_quanxue_comp');
```

### 2. 随机抽取题目

```javascript
// 从指定古诗文中随机抽取题目
const questions = utils.getRandomQuestions(
    ['01_quanxue', '02_xiaoyaoyou'], // 古诗文ID数组
    5,                                // 题目数量
    'fillBack'                        // 练习类型
);
```

### 3. 获取所有古诗文列表

```javascript
const allPoems = utils.getAllPoems();
// 返回包含id、title、author、type的数组
```

### 4. 多篇组合练习

```javascript
const multiExercise = multiPoemExercises.classic_combination;
// 包含组合练习的配置信息
```

## 实际应用示例

### 示例1：单篇前后文默写

```javascript
// 获取《劝学》的所有句子
const quanxue = utils.getPoemById('01_quanxue');
const sentences = quanxue.sentences;

// 随机选择一句进行练习
const randomSentence = sentences[Math.floor(Math.random() * sentences.length)];

// 根据练习类型决定显示内容
if (exerciseType === 'fillBack') {
    // 显示前半句，要求填写后半句
    question = randomSentence.front;
    answer = randomSentence.back;
} else if (exerciseType === 'fillFront') {
    // 显示后半句，要求填写前半句
    question = randomSentence.back;
    answer = randomSentence.front;
}
```

### 示例2：理解性默写

```javascript
// 获取《劝学》的理解性默写题目
const quanxueComp = utils.getComprehensiveById('01_quanxue_comp');

// 随机选择一个问题
const randomQuestion = quanxueComp.questions[
    Math.floor(Math.random() * quanxueComp.questions.length)
];

// 显示问题和提示
question = randomQuestion.question;
hint = randomQuestion.hint;
answer = randomQuestion.answer;
```

### 示例3：多篇组合练习

```javascript
// 从多篇古诗文中随机抽取题目
const multiQuestions = utils.getRandomQuestions(
    ['01_quanxue', '02_xiaoyaoyou', '03_shishuo'],
    8,
    'fillBack'
);

// 每个题目都包含来源信息
multiQuestions.forEach(q => {
    console.log(`来自: ${q.sourcePoem}, 题目: ${q.front}, 答案: ${q.back}`);
});
```

## 扩展建议

### 1. 添加更多古诗文
在 `poemDatabase.contextual` 中添加新的古诗文，确保ID唯一。

### 2. 增加理解性默写题目
在 `poemDatabase.comprehensive` 中添加更多理解性默写题目。

### 3. 自定义练习模式
可以基于现有结构创建新的练习模式，如：
- 关键词填空
- 整篇默写
- 主题分类练习

### 4. 数据验证
建议在使用前验证数据的完整性：
```javascript
function validatePoemData(poem) {
    return poem.id && poem.title && poem.sentences && 
           poem.sentences.length > 0;
}
```

## 注意事项

1. **ID唯一性**: 确保所有ID都是唯一的，避免冲突
2. **数据完整性**: 每个句子都应该有完整的front和back字段
3. **错误处理**: 在使用工具函数时添加适当的错误处理
4. **性能优化**: 对于大量数据，考虑使用索引或缓存机制

这个新的数据结构设计更加清晰、规范，便于维护和扩展，完全满足您提出的所有要求。
